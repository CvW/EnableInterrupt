// in vim, :set ts=2 sts=2 sw=2 et

// My Enable Interrupts

// The External Interrupts are triggered by the INT0 and INT1 pins or any of the PCINT23...0 pins.

// PIN CHANGE INTERRUPT REGISTER BESTIARY
The pin change interrupt PCI2 will trigger if any enabled PCINT[23:16] pin toggles.
The pin change interrupt PCI1 will trigger if any enabled PCINT[14:8] pin toggles.
The pin change interrupt PCI0 will trigger if any enabled PCINT[7:0] pin toggles.
The PCMSK2, PCMSK1 and PCMSK0 Registers control which pins contribute to the pin change interrupts.
Pin change interrupts on PCINT23...0 are detected asynchronously. This implies that these interrupts
can be used for waking the part also from sleep modes other than Idle mode.

// GLOBALLY
SREG:  7   6   5   4   3   2   1   0  (AVR Status Register)
       I -Global Interrupt Enable bit  Set to enable interrupts.
      rw

// PIN CHANGE INTERRUPTS REGISTER BESTIARY
PCICR: 7   6   5   4   3   2   1   0  (When PCIE2 is set and GIE is set, PCI2 is enabled)
                       PCIE2   1   0   Likewise for 1 and 0.
       -   -   -   -   -  rw  rw  rw

PCMSK2:7   6   5   4   3   2   1   0  (Selects whether pin change interrupt is enabled on PCINT23:16
  PCINT23           ...      PCINT16   If PCIE2 in PCICR and this bit is set, it is enabled on that
      rw  rw  rw  rw  rw  rw  rw  rw   pin.)
    PD7  PD6 PD5 PD4 PD3 PD2 PD1 PD0   =PORTD

PCMSK1:7   6   5   4   3   2   1   0  (Selects whether pin change interrupt is enabled on PCINT14:8
       - PCINT14    ...       PCINT8   If PCIE1 in PCICR and this bit is set, it is enabled on that
       r  rw  rw  rw  rw  rw  rw  rw   pin.)
         PC6 PC5 PC4 PC3 PC2 PC1 PC0   =PORTC

PCMSK0:7   6   5   4   3   2   1   0  (Selects whether pin change interrupt is enabled on PCINT7:0
  PCINT7            ...       PCINT0   If PCIE0 in PCICR and this bit is set, it is enabled on that
      rw  rw  rw  rw  rw  rw  rw  rw   pin.)
     PB7 PB6 PB5 PB4 PB3 PB2 PB1 PB0   =PORTB

// set...
PCIFR: 7   6   5   4   3   2   1   0  (When logic change triggers IRQ, bececomes set. Cleared when
                       PCIF2   1   0   IRQ is executed. PCIF2 == PCIE2, etc.)
       -   -   -   -   -  rw  rw  rw

// EXTERNAL INTERRUPTS REGISTER BESTIARY

EICRA: 7   6   5   4   3   2   1   0  (External Interrupt Control Register A)
                 ISC  11  10  01  00  Interrupt Sense Control Bits
       -   -   -   -  rw  rw  rw  rw

        ISC11 / ISC10 : INT1    ISC01 / ISC00
          0      0    Low       (similar to ISC11/10)
          0      1    Change
          1      0    Falling
          1      1    Rising

EIMSK:  7   6   5   4   3   2   1   0  (External Interrupt Mask Register)
                              INT1 INT0
        -   -   -   -   -   -  rw  rw   set to 1 to enable this interrupt

// set...
EIFR: INTF1: Bit 1: set when edge/logic chg on INT1 triggers IRQ.  Cleared  when IRQ executed.
      INTF0: Bit 0: set when edge/logic chg on INT0 triggers IRQ.  Cleared  when IRQ executed.


The INT0 and INT1 interrupts can be triggered by a falling or rising edge or a low level. This is
set up as indicated in the specification for the External Interrupt Control Register A â€“ EICRA.
When the INT0 or INT1 interrupts are enabled and are configured as level triggered, the inter-
rupts will trigger as long as the pin is held low.
Low level interrupt on INT0 and INT1 is detected asynchronously. This implies that this interrupt
can be used for waking the part also from sleep modes other than Idle mode. The I/O clock is halted
in all sleep modes except Idle mode.

// 

#define PINCHANGEINTERRUPT 0x80
#define SLOWINTERRUPT      0x80

void enableInterrupt(uint8_t interruptDesignator, void (*userFunction)(void), uint8_t mode) {
  uint8_t arduinoPin;

  arduinoPin=interruptDesignator & ~PINCHANGEINTERRUPT;
	if (interruptDesignator && PINCHANGEINTERRUPT) {
    
  } else {
  }
}

void 


=============================================================================================

Fri Jan 23 21:51:01 CST 2015
PROBLEM:
I have a "dirty" switch: it bounces a lot when pressed. The bounces can occur on the order of
microseconds apart. So pretend I have turned on a port as an input port, and the pullup resistor
is on. I have enabled a Pin Change Interrupt on the pin. It will trigger on any level change.
So when I press the switch, the signal goes from high to low and the interrupt is triggered.

Notice that for Pin Change Interrupts, the interrupt can take place when any pin on the port is
interrupted. If you have the luxury of knowing ahead of time which pin(s) are interrupting, you
can design fast, custom code that will react to your simple situation. But remember that I am
writing a library: I don't know which pin may be doing the interrupting. So I have to survey the
pins to figure out which one(s) changed, and had triggered the interrupt. Furthermore, there is
an appreciable amount of time that it takes from the moment the triggering event happened to
when I enter the interrupt subroutine (ISR) and have gone through the logic to figure out which
pins did the triggering. ...How much time? That I aim to find out.

Why is this a big deal? Remember my bouncy switch? ...The interrupt triggers, the ISR starts up,
and the first thing I need to do is query the port to see the state of its pins. Well, some time
has elapsed since the triggering event and this query. In the course of that time, it's entirely
possible- and I'm writing this because it's not only possible, but it can happen quite readily-
that the state of the pin changes before I get a chance to sample it. So I get an interrupt but
it looks like a false alarm! The ISR never calls the user's function because none of the user's
interrupt pins appear to have changed.

There is no complete solution to this problem, because of the nature of Pin Change Interrupts.
All you can do is mitigate the situation. I will attempt to do so by capturing the state of the
port as early as possible in the ISR. The question is, how early is that?

I attempt a test: my ISR looks like this; this will turn on and off the Arduino Uno's pin 13 LED:

ISR(PORTC_VECT, ISR_NAKED) {
  uint8_t interruptMask;
  uint8_t ledon, ledoff;

  ledon=0b00100000; ledoff=0b0;

  PORTB=ledoff; // LOW
  PORTB=ledon;         // HIGH
  PORTB=ledoff; // LOW
  PORTB=ledon;         // HIGH
  PORTB=ledoff; // LOW
  (...)
}

The generated assembly code looks like this:

00000292 <__vector_4>:
  ledon=0b00100000; ledoff=0b0;

  PORTB=ledoff; // LOW
     292:       15 b8           out     0x05, r1        ; 5
  PORTB=ledon;         // HIGH
     294:       80 e2           ldi     r24, 0x20       ; 32
     296:       85 b9           out     0x05, r24       ; 5
  PORTB=ledoff; // LOW
     298:       15 b8           out     0x05, r1        ; 5
  PORTB=ledon;         // HIGH
     29a:       85 b9           out     0x05, r24       ; 5
  PORTB=ledoff; // LOW
     29c:       15 b8           out     0x05, r1        ; 5

Notice a little optimization here: r1 is defined to always contain 0, so we don't even have to load
a value from memory. 0 is an important number! This makes the initial command very quick, and by using
an oscilloscope we can see just how quickly the chip reacts after receiving the signal.
see just how fast 


***** MACRO vs. INLINE the ISR frontend **************************
The code compiles to very similar assembler. However, the inline is better looking C code.
Refer to the "testing0" branch for comparison.

I will use the INLINE method in the production code.
***** MACRO vs. INLINE the ISR frontend **************************

A lot of the basic Pin and Port definitions are in /usr/avr/include/avr/iom328p.h
